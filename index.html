<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

<script>
  // 1. Inizializzazione di Firebase
  const firebaseConfig = {
      apiKey: "AIzaSyAYjQZxyYDYrxuzYdUtsQnSlKrNFuvwfyo",
      authDomain: "torneo-biliardino.firebaseapp.com",
      projectId: "torneo-biliardino",
      storageBucket: "torneo-biliardino.firebasestorage.app",
      messagingSenderId: "592520260738",
      appId: "1:592520260738:web:8496f057e057cee84d589b",
      measurementId: "G-B6CLT4K3GL"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.firestore();
  const scoresCollection = db.collection("scores");

  // 2. Variabili e costanti globali dell'applicazione
  let savedScores = {}; // Conterrà una copia locale dei dati da Firebase
  const players = ["CHIARA", "FRENKIE", "IRE", "KLM", "LUCA", "TEO"];
  let stats = Object.fromEntries(players.map(p => [p, { points: 0, played: 0, won: 0, goalsFor: 0, goalsAgainst: 0 }]));
  const matches = [
    ["CHIARA", "FRENKIE", "IRE", "KLM"], ["CHIARA", "FRENKIE", "IRE", "LUCA"], ["CHIARA", "FRENKIE", "IRE", "TEO"],
    ["CHIARA", "FRENKIE", "KLM", "LUCA"], ["CHIARA", "FRENKIE", "KLM", "TEO"], ["CHIARA", "FRENKIE", "LUCA", "TEO"],
    ["CHIARA", "IRE", "FRENKIE", "KLM"], ["CHIARA", "IRE", "FRENKIE", "LUCA"], ["CHIARA", "IRE", "FRENKIE", "TEO"],
    ["CHIARA", "IRE", "KLM", "LUCA"], ["CHIARA", "IRE", "KLM", "TEO"], ["CHIARA", "IRE", "LUCA", "TEO"],
    ["CHIARA", "KLM", "FRENKIE", "IRE"], ["CHIARA", "KLM", "FRENKIE", "LUCA"], ["CHIARA", "KLM", "FRENKIE", "TEO"],
    ["CHIARA", "KLM", "IRE", "LUCA"], ["CHIARA", "KLM", "IRE", "TEO"], ["CHIARA", "KLM", "LUCA", "TEO"],
    ["CHIARA", "LUCA", "FRENKIE", "IRE"], ["CHIARA", "LUCA", "FRENKIE", "KLM"], ["CHIARA", "LUCA", "FRENKIE", "TEO"],
    ["CHIARA", "LUCA", "IRE", "KLM"], ["CHIARA", "LUCA", "IRE", "TEO"], ["CHIARA", "LUCA", "KLM", "TEO"],
    ["CHIARA", "TEO", "FRENKIE", "IRE"], ["CHIARA", "TEO", "FRENKIE", "KLM"], ["CHIARA", "TEO", "FRENKIE", "LUCA"],
    ["CHIARA", "TEO", "IRE", "KLM"], ["CHIARA", "TEO", "IRE", "LUCA"], ["CHIARA", "TEO", "KLM", "LUCA"],
    ["FRENKIE", "IRE", "KLM", "LUCA"], ["FRENKIE", "IRE", "KLM", "TEO"], ["FRENKIE", "IRE", "LUCA", "TEO"],
    ["FRENKIE", "KLM", "IRE", "LUCA"], ["FRENKIE", "KLM", "IRE", "TEO"], ["FRENKIE", "KLM", "LUCA", "TEO"],
    ["FRENKIE", "LUCA", "IRE", "KLM"], ["FRENKIE", "LUCA", "IRE", "TEO"], ["FRENKIE", "LUCA", "KLM", "TEO"],
    ["FRENKIE", "TEO", "IRE", "KLM"], ["FRENKIE", "TEO", "IRE", "LUCA"], ["FRENKIE", "TEO", "KLM", "LUCA"],
    ["IRE", "KLM", "LUCA", "TEO"], ["IRE", "LUCA", "KLM", "TEO"], ["IRE", "TEO", "KLM", "LUCA"]
  ].map(([a1, a2, b1, b2]) => [[a1, a2], [b1, b2]]);
  const activePlayerFilters = new Set();
  let currentMatchStatusFilter = 'all';

  // 3. Funzioni dell'applicazione
  function renderFilters() {
    const filterContainer = document.getElementById("player-and-status-filters");
    filterContainer.innerHTML = "";
    players.forEach(p => {
      const btn = document.createElement("button");
      btn.textContent = p; btn.className = "filter-btn";
      if (activePlayerFilters.has(p)) btn.classList.add('active');
      btn.onclick = () => { btn.classList.toggle("active"); activePlayerFilters.has(p) ? activePlayerFilters.delete(p) : activePlayerFilters.add(p); filterMatches(); };
      filterContainer.appendChild(btn);
    });
    const statusFilters = [{ text: "TUTTE", value: "all" }, { text: "GIOCATE", value: "played" }, { text: "DA GIOCARE", value: "unplayed" }];
    statusFilters.forEach(filter => {
      const btn = document.createElement("button");
      btn.textContent = filter.text; btn.className = "filter-btn";
      if (currentMatchStatusFilter === filter.value) btn.classList.add('active');
      btn.onclick = () => { currentMatchStatusFilter = filter.value; renderFilters(); filterMatches(); };
      filterContainer.appendChild(btn);
    });
  }

  function renderMatches() {
    const c = document.getElementById("matches");
    c.innerHTML = "";
    matches.forEach(([e, t], l) => {
      const s = document.createElement("div"); s.className = "match";
      const a = savedScores[l];
      const isPlayed = a && (a.s1 !== undefined && a.s2 !== undefined) && (a.s1 !== 0 || a.s2 !== 0);

      // Aggiunge la classe 'match-started' se ci sono assegnazioni di colore (anche se i punteggi non sono ancora stati inseriti)
      // Questo assicura che il pulsante "Inizia Partita" sia nascosto e la sezione giocatori sia giustificata a sinistra.
      if (a && (a.team1Color || a.s1 !== undefined)) s.classList.add("match-started");

      if (isPlayed) s.classList.add("played");

      // Determina i colori finali o un colore di default vuoto se non impostato o la partita non è stata giocata
      const team1FinalColorClass = a?.team1Color || '';
      const team2FinalColorClass = a?.team2Color || '';

      // Imposta lo stile di visualizzazione per gli indicatori in base al fatto che la partita sia stata giocata
      const indicatorDisplay = isPlayed ? 'none' : 'inline-block'; // Nascondi se la partita è stata giocata

      s.innerHTML = `
        <div class="player-names-section">
          <button class="draw-button" onclick="startMatchDraw(${l})">Inizia Partita</button>
          <div class="player-names">
            <span id="team1-indicator-${l}" class="team-color-indicator ${team1FinalColorClass}" style="display: ${indicatorDisplay};"></span> ${e.join(" & ")} vs
            <span id="team2-indicator-${l}" class="team-color-indicator ${team2FinalColorClass}" style="display: ${indicatorDisplay};"></span> ${t.join(" & ")}
          </div>
        </div>
        <div class="score-section">
          <input type="number" id="s1-${l}" class="score-input" min="0" max="10" value="${a?.s1 !== undefined ? a.s1 : ""}" ${a && a.s1 !== undefined ? "disabled" : ""}>
          -
          <input type="number" id="s2-${l}" class="score-input" min="0" max="10" value="${a?.s2 !== undefined ? a.s2 : ""}" ${a && a.s2 !== undefined ? "disabled" : ""}>
          <button id="submit-btn-${l}" class="submit-btn" onclick="submitScore(${l})" style="display: ${a && a.s1 !== undefined ? "none" : "inline-block"};">OK</button>
          <button id="edit-btn-${l}" class="edit-btn" onclick="editScore(${l})" style="display: ${a && a.s1 !== undefined ? "inline-block" : "none"};">Modifica</button>
        </div>
      `;
      c.appendChild(s);
    });
  }

  function editScore(c) {
    document.getElementById(`s1-${c}`).disabled = false;
    document.getElementById(`s2-${c}`).disabled = false;
    document.getElementById(`submit-btn-${c}`).style.display = "inline-block";
    document.getElementById(`edit-btn-${c}`).style.display = "none";
    // Mostra gli indicatori di colore durante la modifica
    const team1Indicator = document.getElementById(`team1-indicator-${c}`);
    const team2Indicator = document.getElementById(`team2-indicator-${c}`);
    if (team1Indicator) team1Indicator.style.display = 'inline-block';
    if (team2Indicator) team2Indicator.style.display = 'inline-block';
  }

  async function submitScore(c) {
    const e = document.getElementById(`s1-${c}`);
    const t = document.getElementById(`s2-${c}`);
    const l = parseInt(e.value);
    const s = parseInt(t.value);

    // Nascondi gli indicatori di colore immediatamente al tentativo di invio
    const team1Indicator = document.getElementById(`team1-indicator-${c}`);
    const team2Indicator = document.getElementById(`team2-indicator-${c}`);
    if (team1Indicator) team1Indicator.style.display = 'none';
    if (team2Indicator) team2Indicator.style.display = 'none';

    if (!isNaN(l) && !isNaN(s)) {
      if (l === 0 && s === 0) {
        if (confirm("Sei sicuro di voler resettare il punteggio a 0-0? Questo lo rimuoverà dalle partite giocate.")) {
          // Rimuovi anche le assegnazioni di colore quando si resetta a 0-0
          await scoresCollection.doc(String(c)).delete();
        } else {
          e.value = savedScores[c]?.s1 || "";
          t.value = savedScores[c]?.s2 || "";
          // Se l'annullamento è stato annullato, mostra nuovamente gli indicatori se erano presenti
          if (savedScores[c]?.team1Color) team1Indicator.style.display = 'inline-block';
          if (savedScores[c]?.team2Color) team2Indicator.style.display = 'inline-block';
        }
      } else {
        const scoreData = { s1: l, s2: s };
        // Quando un punteggio viene inviato (e non è 0-0), assicurati che i dati del colore vengano rimossi
        // Questo fa sì che gli indicatori scompaiano.
        scoreData.team1Color = firebase.firestore.FieldValue.delete();
        scoreData.team2Color = firebase.firestore.FieldValue.delete();
        await scoresCollection.doc(String(c)).set(scoreData, { merge: true });
      }
    }
  }

  function calculateAllStats() {
    stats = Object.fromEntries(players.map(p => [p, { played: 0, won: 0, goalsFor: 0, goalsAgainst: 0 }]));
    Object.entries(savedScores).forEach(([matchIndex, scoreData]) => {
        const [team1, team2] = matches[parseInt(matchIndex, 10)];
        const score1 = scoreData.s1;
        const score2 = scoreData.s2;
        if ((score1 !== undefined && score2 !== undefined) && (score1 !== 0 || score2 !== 0)) {
            team1.forEach(p => { stats[p].played++; stats[p].goalsFor += score1; stats[p].goalsAgainst += score2; });
            team2.forEach(p => { stats[p].played++; stats[p].goalsFor += score2; stats[p].goalsAgainst += score1; });
            if (score1 > score2) team1.forEach(p => stats[p].won++);
            else if (score2 > score1) team2.forEach(p => stats[p].won++);
        }
    });
    updateLeaderboard();
  }

  function updateLeaderboard() {
    const c = document.getElementById("leaderboard"); c.innerHTML = "";
    const sortedPlayers = Object.entries(stats).sort(([, a], [, b]) => (b.won / b.played || 0) - (a.won / a.played || 0) || b.won - a.won || (b.goalsFor - b.goalsAgainst) - (a.goalsFor - a.goalsAgainst));
    sortedPlayers.forEach(([e, t], l) => {
      const s = t.played > 0 ? Math.round(t.won / t.played * 100) + "%" : "0%";
      const a = document.createElement("tr");
      if (l === 0) a.classList.add("gold"); else if (l === 1) a.classList.add("silver"); else if (l === 2) a.classList.add("bronze");
      a.innerHTML = `<td>${l + 1}</td><td><strong>${e}</strong></td><td>${t.played}</td><td>${t.won}</td><td>${s}</td><td><strong>${t.goalsFor}</strong></td><td>${t.goalsAgainst}</td>`;
      c.appendChild(a);
    });
  }

  function filterMatches() {
    document.querySelectorAll("#matches .match").forEach((matchElement, index) => {
      const [team1, team2] = matches[index];
      const allPlayers = [...team1, ...team2];
      const score = savedScores[index];
      const isPlayed = score && (score.s1 !== undefined && score.s2 !== undefined) && (score.s1 !== 0 || score.s2 !== 0);
      const playerFilterOk = activePlayerFilters.size === 0 || [...activePlayerFilters].every(p => allPlayers.includes(p));
      const statusFilterOk = currentMatchStatusFilter === 'all' || (currentMatchStatusFilter === 'played' && isPlayed) || (currentMatchStatusFilter === 'unplayed' && !isPlayed);
      matchElement.style.display = (playerFilterOk && statusFilterOk) ? "" : "none";
    });
  }

  async function resetScores() {
    if (confirm("Sei SICURO di voler azzerare TUTTI i punteggi dell'intero torneo? Questa azione è IRREVERSIBILE.")) {
      alert("Cancellazione in corso... Potrebbe richiedere qualche secondo.");
      const snapshot = await scoresCollection.get();
      const batch = db.batch();
      snapshot.forEach(doc => { batch.delete(doc.ref); });
      await batch.commit();
      alert("Torneo azzerato!");
    }
  }

  let animationInterval;
  function startMatchDraw(matchIndex) {
    if (animationInterval) clearInterval(animationInterval);
    const team1Indicator = document.getElementById(`team1-indicator-${matchIndex}`);
    const team2Indicator = document.getElementById(`team2-indicator-${matchIndex}`);
    // Assicurati che siano visibili quando inizia il sorteggio
    team1Indicator.style.display = 'inline-block';
    team2Indicator.style.display = 'inline-block';

    let isRedForTeam1 = true; let animationCount = 0; const totalFlashes = 10;
    animationInterval = setInterval(() => {
      if (animationCount < totalFlashes) {
        team1Indicator.style.backgroundColor = isRedForTeam1 ? 'red' : 'blue';
        team2Indicator.style.backgroundColor = isRedForTeam1 ? 'blue' : 'red';
        isRedForTeam1 = !isRedForTeam1; animationCount++;
      } else {
        clearInterval(animationInterval);
        determineStartingTeam(matchIndex);
      }
    }, 100);
  }

  async function determineStartingTeam(matchIndex) {
    const team1Indicator = document.getElementById(`team1-indicator-${matchIndex}`);
    const team2Indicator = document.getElementById(`team2-indicator-${matchIndex}`);
    let team1Color = (Math.random() < 0.5) ? 'blue' : 'red';
    let team2Color = (team1Color === 'blue') ? 'red' : 'blue';
    team1Indicator.className = `team-color-indicator final-${team1Color}`;
    team2Indicator.className = `team-color-indicator final-${team2Color}`;
    await scoresCollection.doc(String(matchIndex)).set({
      team1Color: `final-${team1Color}`,
      team2Color: `final-${team2Color}`
    }, { merge: true });
    // Questo `set` attiverà il listener onSnapshot, che a sua volta chiamerà renderMatches
    // e la classe `match-started` verrà aggiunta, nascondendo il pulsante di sorteggio.
  }

  // 4. Listener di Firebase (si attiva al caricamento e a ogni modifica)
  scoresCollection.onSnapshot(snapshot => {
      console.log("Dati aggiornati ricevuti da Firebase!");
      const newScores = {};
      snapshot.forEach(doc => {
          newScores[doc.id] = doc.data();
      });
      savedScores = newScores;
      // Ad ogni aggiornamento, ridisegna tutta la UI con i dati freschi
      renderFilters();
      renderMatches();
      calculateAllStats();
      filterMatches();
  });

</script>
